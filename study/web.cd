
zoom: {
      pan: {
        enabled: true,
        mode: "x",                // "x" / "y" / "xy"
        modifierKey: "ctrl"       // Ctrl押しながらドラッグでパン（誤操作防止）
      },
      zoom: {
        wheel: { enabled: true }, // ホイールズーム
        pinch: { enabled: true }, // タッチ
        drag: { enabled: true },  // ドラッグ範囲でズーム
        mode: "x"                 // 例：x方向だけズーム
      }
    }
  },

  scales: { ... }
}


(() => {
  const analysisEl = document.getElementById("analysis");
  const canvas = document.getElementById("chart");
  if (!analysisEl || !canvas) return;

  const ctx = canvas.getContext("2d");

  function toPoints(xs, ys) {
    if (!Array.isArray(xs) || !Array.isArray(ys)) return [];
    const n = Math.min(xs.length, ys.length);
    const pts = [];
    for (let i = 0; i < n; i++) {
      const x = xs[i], y = ys[i];
      if (typeof x === "number" && typeof y === "number" && Number.isFinite(x) && Number.isFinite(y)) {
        pts.push({ x, y });
      }
    }
    return pts;
  }

  // --- Chart (1 instance) ---
  const chart = new Chart(ctx, {
    type: "scatter",
    data: {
      datasets: [
        { label: "Left-1",  yAxisID: "yL1", data: [], pointRadius: 2, showLine: false },
        { label: "Left-2",  yAxisID: "yL2", data: [], pointRadius: 2, showLine: false },
        { label: "Right-1", yAxisID: "yR1", data: [], pointRadius: 2, showLine: false },
        { label: "Right-2", yAxisID: "yR2", data: [], pointRadius: 2, showLine: false }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      parsing: false,
      animation: false,
      plugins: {
        title: { display: true, text: "Scatter" },
        legend: { display: true } // 凡例クリックで系列ON/OFF可能
      },
      scales: {
        x: { type: "linear", title: { display: true, text: "ts" } },

        // --- Left (2 axes) ---
        yL1: {
          type: "linear",
          position: "left",
          title: { display: true, text: "left value 1" },
          // グリッドは代表としてこれだけ表示（見やすさ優先）
          grid: { drawOnChartArea: true }
        },
        yL2: {
          type: "linear",
          position: "left",
          offset: true,                  // 左側の2本目を外側にずらす
          title: { display: true, text: "left value 2" },
          grid: { drawOnChartArea: false } // 追加軸のグリッドは消す
        },

        // --- Right (2 axes) ---
        yR1: {
          type: "linear",
          position: "right",
          title: { display: true, text: "right value 1" },
          grid: { drawOnChartArea: false }
        },
        yR2: {
          type: "linear",
          position: "right",
          offset: true,                  // 右側の2本目を外側にずらす
          title: { display: true, text: "right value 2" },
          grid: { drawOnChartArea: false }
        }
      }
    }
  });

  const es = new EventSource("/events");
  es.onmessage = (ev) => {
    let obj;
    try { obj = JSON.parse(ev.data); } catch { return; }

    // 互換: value2 が無い場合に備えて val2/valueB も許容
    const l = obj.left ?? {};
    const r = obj.right ?? {};

    const leftTs   = l.ts;
    const rightTs  = r.ts;

    const leftY1   = l.value;
    const leftY2   = l.value2 ?? l.valueB ?? l.value_2;

    const rightY1  = r.value;
    const rightY2  = r.value2 ?? r.valueB ?? r.value_2;

    const leftPts1  = toPoints(leftTs,  leftY1);
    const leftPts2  = toPoints(leftTs,  leftY2);

    const rightPts1 = toPoints(rightTs, rightY1);
    const rightPts2 = toPoints(rightTs, rightY2);

    const title = (typeof obj.title === "string" && obj.title.length)
      ? obj.title
      : `L1=${leftPts1.length}, L2=${leftPts2.length}, R1=${rightPts1.length}, R2=${rightPts2.length}`;

    chart.options.plugins.title.text = title;

    if (obj.analysis && typeof obj.analysis === "object") {
      analysisEl.textContent = JSON.stringify(obj.analysis, null, 2);
    } else {
      analysisEl.textContent =
        `Left-1 N=${leftPts1.length}\n` +
        `Left-2 N=${leftPts2.length}\n` +
        `Right-1 N=${rightPts1.length}\n` +
        `Right-2 N=${rightPts2.length}`;
    }

    // データ差し替え（4系列）
    chart.data.datasets[0].data = leftPts1;   // yL1
    chart.data.datasets[1].data = leftPts2;   // yL2
    chart.data.datasets[2].data = rightPts1;  // yR1
    chart.data.datasets[3].data = rightPts2;  // yR2

    chart.update("none");
  };

  es.onerror = () => {
    analysisEl.textContent = "SSE disconnected (will retry automatically).";
  };
})();




(() => {
  const analysisEl = document.getElementById("analysis");
  const canvas = document.getElementById("chart");
  if (!analysisEl || !canvas) return;

  const ctx = canvas.getContext("2d");

  function toPoints(xs, ys) {
    if (!Array.isArray(xs) || !Array.isArray(ys)) return [];
    const n = Math.min(xs.length, ys.length);
    const pts = [];
    for (let i = 0; i < n; i++) {
      const x = xs[i], y = ys[i];
      if (typeof x === "number" && typeof y === "number" && Number.isFinite(x) && Number.isFinite(y)) {
        pts.push({ x, y });
      }
    }
    return pts;
  }

  // まず1回だけチャートを作る
  const chart = new Chart(ctx, {
    type: "scatter",
    data: {
      datasets: [
        {
          label: "Left (y)",
          yAxisID: "y",
          data: [],
          pointRadius: 2,
          showLine: false
        },
        {
          label: "Right (y1)",
          yAxisID: "y1",
          data: [],
          pointRadius: 2,
          showLine: false
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      parsing: false,
      animation: false,
      plugins: {
        title: { display: true, text: "Scatter" },
        legend: { display: true }
      },
      scales: {
        x: { type: "linear", title: { display: true, text: "ts" } },
        y: {
          type: "linear",
          position: "left",
          title: { display: true, text: "left value" }
        },
        y1: {
          type: "linear",
          position: "right",
          title: { display: true, text: "right value" },
          grid: { drawOnChartArea: false } // 右軸のグリッドは消すと見やすい
        }
      }
    }
  });

  const es = new EventSource("/events");
  es.onmessage = (ev) => {
    let obj;
    try { obj = JSON.parse(ev.data); } catch { return; }

    const leftPts  = toPoints(obj.left?.ts,  obj.left?.value);
    const rightPts = toPoints(obj.right?.ts, obj.right?.value);

    // タイトル（JSONにあればそれを使う）
    const title = (typeof obj.title === "string" && obj.title.length)
      ? obj.title
      : `Left N=${leftPts.length}, Right N=${rightPts.length}`;

    chart.options.plugins.title.text = title;

    // 解析情報（JSON側で作って渡すならそれを表示、なければ簡易）
    if (obj.analysis && typeof obj.analysis === "object") {
      analysisEl.textContent = JSON.stringify(obj.analysis, null, 2);
    } else {
      analysisEl.textContent = `Left N=${leftPts.length}\nRight N=${rightPts.length}`;
    }

    // データ差し替え
    chart.data.datasets[0].data = leftPts;   // y
    chart.data.datasets[1].data = rightPts;  // y1

    chart.update("none");
  };

  es.onerror = () => {
    analysisEl.textContent = "SSE disconnected (will retry automatically).";
  };
})();

<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Scatter Viewer</title>
  <style>
    body { font-family: sans-serif; margin: 16px; }

    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;  /* 左右2カラム */
      gap: 16px;
      align-items: start;
    }

    .panel {
      border: 1px solid #ddd;
      padding: 12px;
      background: #fff;
    }

    .analysis {
      margin: 0 0 10px 0;
      padding: 8px 10px;
      background: #f5f5f5;
      white-space: pre-wrap;
      border: 1px solid #ddd;
      min-height: 90px;
    }

    canvas { width: 100%; height: 420px; border: 1px solid #ddd; }
  </style>

  <!-- ローカル配信にしている想定 -->
  <script src="{{ url_for('static', filename='vendor/chart.umd.min.js') }}"></script>
  <script src="{{ url_for('static', filename='app.js') }}?v={{ cache_bust }}"></script>
</head>
<body>
  <h2>Two Charts</h2>

  <div class="row">
    <div class="panel">
      <div id="analysis1" class="analysis">waiting...</div>
      <canvas id="chart1"></canvas>
    </div>

    <div class="panel">
      <div id="analysis2" class="analysis">waiting...</div>
      <canvas id="chart2"></canvas>
    </div>
  </div>
</body>
</html>

(() => {
  const analysis1 = document.getElementById("analysis1");
  const analysis2 = document.getElementById("analysis2");
  const c1 = document.getElementById("chart1");
  const c2 = document.getElementById("chart2");
  if (!analysis1 || !analysis2 || !c1 || !c2) return;

  const ctx1 = c1.getContext("2d");
  const ctx2 = c2.getContext("2d");

  let chart1 = null;
  let chart2 = null;

  function toPoints(xs, ys) {
    if (!Array.isArray(xs) || !Array.isArray(ys)) return [];
    const n = Math.min(xs.length, ys.length);
    const pts = [];
    for (let i = 0; i < n; i++) {
      const x = xs[i], y = ys[i];
      if (typeof x === "number" && typeof y === "number" && Number.isFinite(x) && Number.isFinite(y)) {
        pts.push({ x, y });
      }
    }
    return pts;
  }

  function formatAnalysisFromObject(obj) {
    // analysis を JSON 文字列で表示（任意）
    if (obj && typeof obj === "object") return JSON.stringify(obj, null, 2);
    return "";
  }

  function renderScatter(ctx, points, titleText, existingChart) {
    if (existingChart) existingChart.destroy();

    return new Chart(ctx, {
      type: "scatter",
      data: {
        datasets: [{
          label: "points",
          data: points,
          pointRadius: 2,
          showLine: false
        }]
      },
      options: {
        animation: false,
        responsive: true,
        parsing: false,
        plugins: {
          title: { display: true, text: titleText ?? "" }
        },
        scales: {
          x: { type: "linear", title: { display: true, text: "ts" } },
          y: { type: "linear", title: { display: true, text: "value" } }
        }
      }
    });
  }

  function updateSide(sideObj, analysisEl, ctx, currentChart, fallbackTitle) {
    if (!sideObj || typeof sideObj !== "object") {
      analysisEl.textContent = "No data.";
      if (currentChart) currentChart.destroy();
      return null;
    }

    const points = toPoints(sideObj.ts, sideObj.value);

    const title =
      (typeof sideObj.title === "string" && sideObj.title.length > 0)
        ? sideObj.title
        : `${fallbackTitle} (N=${points.length})`;

    const analysisText =
      (sideObj.analysis && typeof sideObj.analysis === "object")
        ? formatAnalysisFromObject(sideObj.analysis)
        : `N=${points.length}`;

    analysisEl.textContent = analysisText;

    return renderScatter(ctx, points, title, currentChart);
  }

  const es = new EventSource("/events");

  es.onmessage = (ev) => {
    let obj;
    try { obj = JSON.parse(ev.data); } catch { return; }

    // 左右別データ
    chart1 = updateSide(obj.left, analysis1, ctx1, chart1, "Left");
    chart2 = updateSide(obj.right, analysis2, ctx2, chart2, "Right");
  };

  es.onerror = () => {
    analysis1.textContent = "SSE disconnected (will retry automatically).";
    analysis2.textContent = "SSE disconnected (will retry automatically).";
  };
})();