
(() => {
  const analysisEl = document.getElementById("analysis");
  const canvas = document.getElementById("chart");
  if (!analysisEl || !canvas) return;

  const ctx = canvas.getContext("2d");

  function toPoints(xs, ys) {
    if (!Array.isArray(xs) || !Array.isArray(ys)) return [];
    const n = Math.min(xs.length, ys.length);
    const pts = [];
    for (let i = 0; i < n; i++) {
      const x = xs[i], y = ys[i];
      if (typeof x === "number" && typeof y === "number" && Number.isFinite(x) && Number.isFinite(y)) {
        pts.push({ x, y });
      }
    }
    return pts;
  }

  // まず1回だけチャートを作る
  const chart = new Chart(ctx, {
    type: "scatter",
    data: {
      datasets: [
        {
          label: "Left (y)",
          yAxisID: "y",
          data: [],
          pointRadius: 2,
          showLine: false
        },
        {
          label: "Right (y1)",
          yAxisID: "y1",
          data: [],
          pointRadius: 2,
          showLine: false
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      parsing: false,
      animation: false,
      plugins: {
        title: { display: true, text: "Scatter" },
        legend: { display: true }
      },
      scales: {
        x: { type: "linear", title: { display: true, text: "ts" } },
        y: {
          type: "linear",
          position: "left",
          title: { display: true, text: "left value" }
        },
        y1: {
          type: "linear",
          position: "right",
          title: { display: true, text: "right value" },
          grid: { drawOnChartArea: false } // 右軸のグリッドは消すと見やすい
        }
      }
    }
  });

  const es = new EventSource("/events");
  es.onmessage = (ev) => {
    let obj;
    try { obj = JSON.parse(ev.data); } catch { return; }

    const leftPts  = toPoints(obj.left?.ts,  obj.left?.value);
    const rightPts = toPoints(obj.right?.ts, obj.right?.value);

    // タイトル（JSONにあればそれを使う）
    const title = (typeof obj.title === "string" && obj.title.length)
      ? obj.title
      : `Left N=${leftPts.length}, Right N=${rightPts.length}`;

    chart.options.plugins.title.text = title;

    // 解析情報（JSON側で作って渡すならそれを表示、なければ簡易）
    if (obj.analysis && typeof obj.analysis === "object") {
      analysisEl.textContent = JSON.stringify(obj.analysis, null, 2);
    } else {
      analysisEl.textContent = `Left N=${leftPts.length}\nRight N=${rightPts.length}`;
    }

    // データ差し替え
    chart.data.datasets[0].data = leftPts;   // y
    chart.data.datasets[1].data = rightPts;  // y1

    chart.update("none");
  };

  es.onerror = () => {
    analysisEl.textContent = "SSE disconnected (will retry automatically).";
  };
})();

<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Scatter Viewer</title>
  <style>
    body { font-family: sans-serif; margin: 16px; }

    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;  /* 左右2カラム */
      gap: 16px;
      align-items: start;
    }

    .panel {
      border: 1px solid #ddd;
      padding: 12px;
      background: #fff;
    }

    .analysis {
      margin: 0 0 10px 0;
      padding: 8px 10px;
      background: #f5f5f5;
      white-space: pre-wrap;
      border: 1px solid #ddd;
      min-height: 90px;
    }

    canvas { width: 100%; height: 420px; border: 1px solid #ddd; }
  </style>

  <!-- ローカル配信にしている想定 -->
  <script src="{{ url_for('static', filename='vendor/chart.umd.min.js') }}"></script>
  <script src="{{ url_for('static', filename='app.js') }}?v={{ cache_bust }}"></script>
</head>
<body>
  <h2>Two Charts</h2>

  <div class="row">
    <div class="panel">
      <div id="analysis1" class="analysis">waiting...</div>
      <canvas id="chart1"></canvas>
    </div>

    <div class="panel">
      <div id="analysis2" class="analysis">waiting...</div>
      <canvas id="chart2"></canvas>
    </div>
  </div>
</body>
</html>

(() => {
  const analysis1 = document.getElementById("analysis1");
  const analysis2 = document.getElementById("analysis2");
  const c1 = document.getElementById("chart1");
  const c2 = document.getElementById("chart2");
  if (!analysis1 || !analysis2 || !c1 || !c2) return;

  const ctx1 = c1.getContext("2d");
  const ctx2 = c2.getContext("2d");

  let chart1 = null;
  let chart2 = null;

  function toPoints(xs, ys) {
    if (!Array.isArray(xs) || !Array.isArray(ys)) return [];
    const n = Math.min(xs.length, ys.length);
    const pts = [];
    for (let i = 0; i < n; i++) {
      const x = xs[i], y = ys[i];
      if (typeof x === "number" && typeof y === "number" && Number.isFinite(x) && Number.isFinite(y)) {
        pts.push({ x, y });
      }
    }
    return pts;
  }

  function formatAnalysisFromObject(obj) {
    // analysis を JSON 文字列で表示（任意）
    if (obj && typeof obj === "object") return JSON.stringify(obj, null, 2);
    return "";
  }

  function renderScatter(ctx, points, titleText, existingChart) {
    if (existingChart) existingChart.destroy();

    return new Chart(ctx, {
      type: "scatter",
      data: {
        datasets: [{
          label: "points",
          data: points,
          pointRadius: 2,
          showLine: false
        }]
      },
      options: {
        animation: false,
        responsive: true,
        parsing: false,
        plugins: {
          title: { display: true, text: titleText ?? "" }
        },
        scales: {
          x: { type: "linear", title: { display: true, text: "ts" } },
          y: { type: "linear", title: { display: true, text: "value" } }
        }
      }
    });
  }

  function updateSide(sideObj, analysisEl, ctx, currentChart, fallbackTitle) {
    if (!sideObj || typeof sideObj !== "object") {
      analysisEl.textContent = "No data.";
      if (currentChart) currentChart.destroy();
      return null;
    }

    const points = toPoints(sideObj.ts, sideObj.value);

    const title =
      (typeof sideObj.title === "string" && sideObj.title.length > 0)
        ? sideObj.title
        : `${fallbackTitle} (N=${points.length})`;

    const analysisText =
      (sideObj.analysis && typeof sideObj.analysis === "object")
        ? formatAnalysisFromObject(sideObj.analysis)
        : `N=${points.length}`;

    analysisEl.textContent = analysisText;

    return renderScatter(ctx, points, title, currentChart);
  }

  const es = new EventSource("/events");

  es.onmessage = (ev) => {
    let obj;
    try { obj = JSON.parse(ev.data); } catch { return; }

    // 左右別データ
    chart1 = updateSide(obj.left, analysis1, ctx1, chart1, "Left");
    chart2 = updateSide(obj.right, analysis2, ctx2, chart2, "Right");
  };

  es.onerror = () => {
    analysis1.textContent = "SSE disconnected (will retry automatically).";
    analysis2.textContent = "SSE disconnected (will retry automatically).";
  };
})();