using System;
using System.Text.Json;
using NetMQ;
using NetMQ.Sockets;

public sealed class ZmqJsonDocSubscriber : IDisposable
{
    private readonly SubscriberSocket _sub;
    private readonly NetMQPoller _poller;

    // (topic, jsonDocument, rawJson)
    // 注意: JsonDocument は IDisposable。ハンドラ側で Dispose してください（下に例あり）。
    public event Action<string?, JsonDocument, string>? MessageReceived;

    public event Action<string?, string, Exception>? ParseError; // (topic, rawJson, ex)

    public ZmqJsonDocSubscriber(string endpoint, string? topic = null)
    {
        AsyncIO.ForceDotNet.Force();

        _sub = new SubscriberSocket();
        _sub.Connect(endpoint);

        if (string.IsNullOrEmpty(topic))
            _sub.SubscribeToAnyTopic();
        else
            _sub.Subscribe(topic);

        _sub.ReceiveReady += (_, __) => OnReceive();
        _poller = new NetMQPoller { _sub };
    }

    public void Start() => _poller.RunAsync();

    public void Stop()
    {
        if (_poller.IsRunning) _poller.Stop();
    }

    private void OnReceive()
    {
        // multipart(topic + json) / single(json) の両対応
        string? topic = null;
        string rawJson;

        var msg = _sub.ReceiveMultipartMessage();

        if (msg.FrameCount == 1)
        {
            rawJson = msg[0].ConvertToString();
        }
        else
        {
            topic = msg[0].ConvertToString();
            rawJson = msg[1].ConvertToString();
        }

        try
        {
            var doc = JsonDocument.Parse(rawJson);
            MessageReceived?.Invoke(topic, doc, rawJson);
            // doc.Dispose() は購読側（イベントハンドラ側）で実行してください
        }
        catch (Exception ex) when (ex is JsonException or ArgumentException)
        {
            ParseError?.Invoke(topic, rawJson, ex);
        }
    }

    public void Dispose()
    {
        Stop();
        _sub.Dispose();
        _poller.Dispose();
        NetMQConfig.Cleanup();
    }
}

// ------------------------
// 使い方例
// ------------------------
public static class Example
{
    public static void Run()
    {
        var sub = new ZmqJsonDocSubscriber("tcp://127.0.0.1:5556", topic: "status");

        sub.MessageReceived += (topic, doc, raw) =>
        {
            try
            {
                var root = doc.RootElement;

                // 例: {"ts":"...","value":123.4,"status":"ok"}
                if (root.TryGetProperty("value", out var v) && v.TryGetDouble(out var value))
                {
                    Console.WriteLine($"topic={topic ?? "(none)"} value={value}");
                }

                if (root.TryGetProperty("status", out var s) && s.ValueKind == JsonValueKind.String)
                {
                    Console.WriteLine($"status={s.GetString()}");
                }
            }
            finally
            {
                // 重要: JsonDocument は Dispose する
                doc.Dispose();
            }
        };

        sub.ParseError += (topic, raw, ex) =>
        {
            Console.WriteLine($"JSON parse error topic={topic ?? "(none)"}: {ex.Message}");
            Console.WriteLine(raw);
        };

        sub.Start();

        Console.WriteLine("SUB running. Press Enter to exit.");
        Console.ReadLine();

        sub.Dispose();
    }
}


using System;
using System.Text.Json;
using NetMQ;
using NetMQ.Sockets;

public sealed class ZmqJsonSubscriber<T> : IDisposable
{
    private readonly SubscriberSocket _sub;
    private readonly NetMQPoller _poller;

    // 受信した結果を外に通知（topic付き）
    public event Action<string?, T, string>? MessageReceived; // (topic, data, rawJson)

    private readonly JsonSerializerOptions _jsonOptions;

    public ZmqJsonSubscriber(string endpoint, string? topic = null, JsonSerializerOptions? jsonOptions = null)
    {
        AsyncIO.ForceDotNet.Force();

        _jsonOptions = jsonOptions ?? new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true
        };

        _sub = new SubscriberSocket();
        _sub.Connect(endpoint);

        if (string.IsNullOrEmpty(topic))
            _sub.SubscribeToAnyTopic();
        else
            _sub.Subscribe(topic);

        _sub.ReceiveReady += (_, __) => OnReceive();

        _poller = new NetMQPoller { _sub };
    }

    public void Start() => _poller.RunAsync();

    private void OnReceive()
    {
        // 受信が multipart(topic+json) か single(json) かを吸収する
        string? topic = null;
        string rawJson;

        // NetMQMessageでまとめて受けるとフレーム数を見られて便利
        var msg = _sub.ReceiveMultipartMessage();

        if (msg.FrameCount == 1)
        {
            rawJson = msg[0].ConvertToString();
        }
        else
        {
            topic = msg[0].ConvertToString();
            rawJson = msg[1].ConvertToString();
        }

        try
        {
            var data = JsonSerializer.Deserialize<T>(rawJson, _jsonOptions);
            if (data is null) return;

            MessageReceived?.Invoke(topic, data, rawJson);
        }
        catch (JsonException)
        {
            // JSONが壊れている/想定外：ここでログに残すなど
            // 必要なら rawJson をイベントで流す設計にしてもよい
        }
    }

    public void Dispose()
    {
        if (_poller.IsRunning) _poller.Stop();
        _sub.Dispose();
        _poller.Dispose();
        NetMQConfig.Cleanup();
    }
}


using System.Net.WebSockets;
using System.Text;
using System.Windows;

using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Hosting;

public partial class MainWindow : Window
{
    private IHost? _host;

    public MainWindow()
    {
        InitializeComponent();
        StartWebSocketServer();
    }

    private void StartWebSocketServer()
    {
        // UI スレッドを塞がないように Host を起動
        _host = Host.CreateDefaultBuilder()
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseKestrel();
                webBuilder.UseUrls("http://127.0.0.1:5005"); // 好きなポートに
                webBuilder.Configure(app =>
                {
                    app.UseWebSockets();

                    app.Map("/ws", async context =>
                    {
                        if (!context.WebSockets.IsWebSocketRequest)
                        {
                            context.Response.StatusCode = 400;
                            await context.Response.WriteAsync("WebSocket only.");
                            return;
                        }

                        using var ws = await context.WebSockets.AcceptWebSocketAsync();
                        var buffer = new byte[16 * 1024];

                        while (ws.State == WebSocketState.Open)
                        {
                            var result = await ws.ReceiveAsync(buffer, CancellationToken.None);

                            if (result.MessageType == WebSocketMessageType.Close)
                            {
                                await ws.CloseAsync(WebSocketCloseStatus.NormalClosure, "bye", CancellationToken.None);
                                break;
                            }

                            var msg = Encoding.UTF8.GetString(buffer, 0, result.Count);

                            // UI 更新は Dispatcher 経由
                            Dispatcher.Invoke(() =>
                            {
                                // 例：ListBox や TextBox に表示する等
                                // MyTextBox.AppendText(msg + Environment.NewLine);
                                Title = $"Rx: {msg}";
                            });

                            // エコー返信
                            var reply = Encoding.UTF8.GetBytes($"echo: {msg}");
                            await ws.SendAsync(reply, WebSocketMessageType.Text, true, CancellationToken.None);
                        }
                    });

                    app.MapGet("/", () => "OK. Connect ws://127.0.0.1:5005/ws");
                });
            })
            .Build();

        _ = _host.StartAsync(); // await しない（バックグラウンド起動）
    }

    protected override async void OnClosed(EventArgs e)
    {
        base.OnClosed(e);

        if (_host != null)
        {
            await _host.StopAsync();
            _host.Dispose();
        }
    }
}