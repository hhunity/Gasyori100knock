using System.Net.Http.Headers;

static HttpClient CreateClient(int maxConn, TimeSpan timeout)
{
    var handler = new SocketsHttpHandler
    {
        MaxConnectionsPerServer = maxConn,
        PooledConnectionLifetime = TimeSpan.FromMinutes(10),
    };
    return new HttpClient(handler) { Timeout = timeout };
}

var sseClient = CreateClient(maxConn: 10, timeout: Timeout.InfiniteTimeSpan);
var apiClient = CreateClient(maxConn: 10, timeout: TimeSpan.FromSeconds(30));

using var sseCts = new CancellationTokenSource();

// SSE 開始（awaitしない）
var sseTask = SubscribeAsync(
    sseClient,
    "http://localhost:8080/events",
    e => Console.WriteLine($"[{e.Event}] {e.Data}"),
    sseCts.Token);

// PUT（SSEと別接続で必ず飛ぶ）
var put = await apiClient.PutAsync("http://localhost:8080/start", content: null);
Console.WriteLine(await put.Content.ReadAsStringAsync());

var req = new HttpRequestMessage(HttpMethod.Put, "http://localhost:8080/start");
req.Headers.ConnectionClose = true;
var resp = await apiClient.SendAsync(req);


using System;
using System.IO;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

public sealed class SseClient
{
    private readonly HttpClient _http;

    public SseClient(HttpClient http) => _http = http;

    // onMessage: (eventName, id, data)
    public async Task SubscribeAsync(
        Uri uri,
        Action<string?, string?, string?> onMessage,
        CancellationToken ct)
    {
        using var req = new HttpRequestMessage(HttpMethod.Get, uri);
        req.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue("text/event-stream"));

        using var res = await _http.SendAsync(req, HttpCompletionOption.ResponseHeadersRead, ct);
        res.EnsureSuccessStatusCode();

        await using var stream = await res.Content.ReadAsStreamAsync(ct);
        using var reader = new StreamReader(stream, Encoding.UTF8);

        string? eventName = null;
        string? eventId = null;
        var data = new StringBuilder();

        while (!reader.EndOfStream && !ct.IsCancellationRequested)
        {
            var line = await reader.ReadLineAsync();
            if (line == null) break;

            // イベント終端（空行）
            if (line.Length == 0)
            {
                if (eventName != null || eventId != null || data.Length > 0)
                {
                    var payload = data.Length > 0 ? data.ToString().TrimEnd('\n') : null;
                    onMessage(eventName, eventId, payload);

                    eventName = null;
                    eventId = null;
                    data.Clear();
                }
                continue;
            }

            // コメント行(: pingなど)
            if (line.StartsWith(":", StringComparison.Ordinal))
                continue;

            var idx = line.IndexOf(':');
            string field, value;
            if (idx < 0)
            {
                field = line;
                value = "";
            }
            else
            {
                field = line.Substring(0, idx);
                value = line.Substring(idx + 1);
                if (value.StartsWith(" ", StringComparison.Ordinal)) value = value.Substring(1);
            }

            switch (field)
            {
                case "event": eventName = value; break;
                case "id":    eventId = value; break;
                case "data":  data.Append(value).Append('\n'); break;
            }
        }
    }
}


using System;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

public sealed class JobClient
{
    private readonly HttpClient _http;
    private readonly Uri _sseUri;

    public JobClient(HttpClient http, Uri sseUri)
    {
        _http = http;
        _sseUri = sseUri;
    }

    public async Task<string> PutAndWaitCompleteAsync(
        Uri putUri,
        object putJsonBody,
        TimeSpan timeout,
        CancellationToken externalCt)
    {
        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(externalCt);
        linkedCts.CancelAfter(timeout);
        var ct = linkedCts.Token;

        var sse = new SseClient(_http);

        // jobId -> 完了待ち
        string? targetJobId = null;

        var tcs = new TaskCompletionSource<string>(TaskCreationOptions.RunContinuationsAsynchronously);

        // 1) SSE購読開始（先に張る：取りこぼし防止）
        var sseTask = sse.SubscribeAsync(_sseUri, (ev, id, data) =>
        {
            if (data == null) return;

            try
            {
                using var doc = JsonDocument.Parse(data);
                var root = doc.RootElement;

                // jobId がある前提
                if (!root.TryGetProperty("jobId", out var jobIdEl)) return;
                var jobId = jobIdEl.GetString();
                if (string.IsNullOrEmpty(jobId)) return;

                // まだ targetJobId 未確定なら無視（PUT応答で確定させる）
                if (targetJobId == null) return;
                if (!string.Equals(jobId, targetJobId, StringComparison.Ordinal)) return;

                // stateを見てcompleteで解放
                var state = root.TryGetProperty("state", out var s) ? s.GetString() : ev;

                if (string.Equals(state, "complete", StringComparison.OrdinalIgnoreCase))
                {
                    var result = root.TryGetProperty("result", out var r) ? r.ToString() : data;
                    tcs.TrySetResult(result ?? "OK");
                }
                else if (string.Equals(state, "error", StringComparison.OrdinalIgnoreCase))
                {
                    tcs.TrySetException(new InvalidOperationException($"Job error: {data}"));
                }
                // progress は無視 or UI更新に使う
            }
            catch
            {
                // JSONでない通知なら、必要に応じて無視/ログ
            }

        }, ct);

        // 2) PUT送信（jobIdを取得）
        var json = JsonSerializer.Serialize(putJsonBody);
        using var content = new StringContent(json, Encoding.UTF8, "application/json");
        using var res = await _http.PutAsync(putUri, content, ct);
        res.EnsureSuccessStatusCode();

        // サーバが { "jobId": "abc123" } を返す想定
        var resBody = await res.Content.ReadAsStringAsync(ct);
        targetJobId = ExtractJobId(resBody);
        if (string.IsNullOrEmpty(targetJobId))
            throw new InvalidOperationException($"PUT response has no jobId: {resBody}");

        // 3) 完了通知を待つ（timeout/cancelで終了）
        try
        {
            var result = await tcs.Task.WaitAsync(ct);
            return result;
        }
        finally
        {
            // SSE停止（購読ループはctキャンセルで止まる）
            // linkedCts.Dispose() で止まる
        }
    }

    private static string? ExtractJobId(string json)
    {
        try
        {
            using var doc = JsonDocument.Parse(json);
            if (doc.RootElement.TryGetProperty("jobId", out var el))
                return el.GetString();
        }
        catch { }
        return null;
    }
}


var http = new HttpClient();

var client = new JobClient(
    http,
    new Uri("http://localhost:8080/events")   // SSE
);

var result = await client.PutAndWaitCompleteAsync(
    new Uri("http://localhost:8080/api/doWork"), // PUT先
    new { param1 = 123, mode = "fast" },         // PUT JSON
    timeout: TimeSpan.FromSeconds(30),
    externalCt: CancellationToken.None
);

Console.WriteLine($"DONE: {result}");


